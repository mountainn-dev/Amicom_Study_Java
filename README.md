# Amicom 자바 스터디 연습장

- 아미콤 자바 스터디 전용 레포지토리입니다.
- 매 주차마다 학습 내용과 실습 내용을 README 파일과 main 클래스 파일에 자유롭게 작성합니다.
- 정해진 작성 형식은 없습니다.

## 1주차 배운 내용
- -참조 타입:객체의 번지를 참조하는 타입(배열,열거,클래스,인터페이스 타입등) -객체 : 데이터+메소드(메소드는 C의 함수같은 것)

-메소드 영역: 바이트코드 파일을 읽은 내용이 저장되는 영역 -힙 영역: 객체가 생성되는 영역 -스택 영역: 메소드를 호출할 때마다 생성된는 프레임이 저장되는 영역

==,!=연산자로 번지를 비교(같은 객체인지 구분) -null: 아직 번지를 저장하고 있지 않다 
-예외(exception): 프로그램 실행 도중 발생하는 오류
-null exception: 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 떄 발생 --- 참조 변수가 객체를 정확히 참조하도록 번지를 대입 
-어떤 변수에도 객체 참조X --- 해당 객체는 프로그램에서 사용X --- 쓰레기 수집기로 자동 제거됨
-String: 문자열 객체 -new 연산자: 새로운 객체를 만드는 객체 생성 연산자 
-equals()메소드: 내부 문자열만을 비교 
-charAt()메소드: 매개값으로 주어진 인덱스의 문자를 리턴 (ex charAt(3)은 해당 문자열의 3번쩨 문자를 의미) (인덱스: 0부터 문자열 길이-1까지의 번호 --- 0부터 세기 떄문) 
-length()메소드: 문자열에서 문자의 개수(공백 포함) 
-replace()메소드: 기존 문자열은 그대로 두고, 대체한 새로운 문자열을 리턴(수정하는 것이 아닌 새로운 문자열 생성) 
-substring()메소드: 특정 위치의 문자열을 잘라내어 가져옴(시작인덱스,종료 인덱스 앞))//(0,9)이면 0번인덱스부터 8번인덱스까지.(8)이면 8번인덱스부터  
-indexOf()메소드: 특정 문자열의 위치를 찾음(주어진 문자열의 시작되는 인덱스를 리턴함) 
-contains()메소드: 주어진 문자열이 단순히 포함되어 있는지만 조사(true, false로 구분) 
-split()메소드: 구분자가 사용된 문자열을 분리함("번호,제목,내용,설명"--- "번호" "제목" "내용" "성명")

-배열: 연속된 공간에 값을 나열시키고, 각 값에 인덱스를 부여한 자료구조(많은 변수가 필요할 떄 유용) 
배열은 같은 타입의 값만 관리 배열의 길이는 늘리거나 줄일 수 없다. --- 새로운 배열을 생성한 뒤 기존 값을 복사하자. 
선언 방법 - 타입[] 변수; (길이는 0부터 시작한다.) 
새로운 변수 선언: 타입[] 변수이름= new 타입[길이] 대입연산자로 해당 인덱스의 내용을 바꿀 수 있다. 
배열변수.length; : 배열의 길이를 얻을 수 있다.(반복문 사용시 배열 안 항목을 일일이 세지 않아도 된다.) 
배열 복사: 
1.System.arraycopy(원본배열,시작 인덱스, 새 배열, 붙여넣기 시작, 복사 항목) 
2.for(타입 변수: 배열) { 실행문 }

다차원 배열: 타입 [][]... 변수이름 = { {(0,1),(0,2),(0,3)...} --- 0번째 배열 {(1,1),(1,2),(1,3)...} --- 1번째 배열 }

Java 시작문이 배열인 이유 = 시작값과 종료값등 실행에 필요한 값이 존재하기 떄문

-열거 타입: 한정된 값을 갖는 타입 첫 문자는 대문자로 캐멀 스타일 데이터 타입 일종이므로 변수 선언 뒤 사용 -열거 상수: 열거 타입으로 사용할 수 있는 한정된 값 알파벳으로 정의 모두 대문자 단어 사이에는 언더바로 연결

## 2주차 배운 내용
- 객체 : 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것
- 필드 : 속성
- 메소드 : 동작, 객체들 사이의 상호작용 수
- 객체 모델링 : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
- 매개값 : 메소드가 실행할 때 필요한 값.
- 리턴값 : 메소드 실행의 결과. 호출한 곳으로 돌려준다.

- 객체 간의 간계
집합관계 : 완성품과 부품의 관계(자동차와 엔진,타이어,핸들의 관계)
사용관계 : 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계(사람이 자동차에게 달린다라는 메소드 호출)
상속관계 : 부모와 자식 관계(자동차가 기계의 필드,메소드를 물려받음)

-객체 지향 프로그래밍의 특징
캡슐화 : 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것(외부 객체는 노출되는 필드,메소드만 이용가능)
         외부의 잘못된 사용으로 객체가 손상되는 것을 막음. 접근 제한자로 캡슐화된 멤버의 노출을 선택할 수 있음
         
상속 : 부모 객체의 필드와 메소드를 자식 객체에게 물려주는 것
       코드의 재사용성을 높여줌(자식 객체에서 중복 코딩 막아줌)
       유지 보수 시간을 최소화 시켜줌(부모 객체의 필드, 메소드를 수정하면 자식 객체에서도 수정된 것을 사용)

다형성 : 동일한 사용 방법에서 실행 결과가 다양하게 나오는 성질(부품에 해당하는 객체를 바꾸면 프로그램 성능이 다르게 나올 수 있음)

-객체와 클래스
클래스 : 설계도에 해당
클래스의 인스턴스 : 클래스로부터 생성된 객체(동일한 클래스로부터 여러 개의 인스턴스(객체)를 만들 수 있음)

-클래스 선언
public class : 공개 클래스를 선언함 (클래스명은 첫 문자는 대문자로, 캐멀 스타일 작성. 첫 문자 숫자X, $,_ 사용가능)
하나의 소스파일에 복수의 클래스를 선언 가능하나, 공개 클래슨느 소스파일명과 동일한 클래스만 가능

-객체 생성과 클래스 변수
new : 객체 생성 연산자 //새로 생성한 객체는 이전 객체와 다른 객체로 인식한다.
클래스 변수 = new 클래스();
클래스의 용도
        1. 라이브러리 클래스 : 실행할 수 없으며 다른 클래스에서 이용하는 클래스
        2. 실행 클래스 : 메소드를 가지고 있는 실행 가능한 클래스

- 클래스의 구성 멤버
필드 : 객체의 데이터가 저장되는 곳 ( 변수선언과 비슷하지만 쓰임새 다름)
생성자 : 객체 생성시 초기화 역할 담당 ( 메소드 선언과 비슷하지만, 리턴이 없고 클래스 이름과 동일함)
메소드 : 객체가 수행할 동작(다른 프로그래밍 언어의 함수와 비슷)

- 필드 선언과 사용
필드 : 객체의 데이터를 저장하는 역할 ( 고유 데이터, 현재 상태 데이터, 부품 데이터)
필드 선언 : 타입 필드명 [ = 초기값]; (변수 선언과 동일하나 클래스 블록에서 선언하여야 한다)
필드 사용 : 필드값을 읽고 변경하는 것 ( 클래스로부터 객체가 생성되야 사용 가능)
도트(.) : 객체 접근 연산자. 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙인다.

-생성자 선언과 호출
클래스에 생성자 선언이 없으면 기본 생성자가 자동 추가된다.
동일한 객체 값일때 필드선언시 초기값 대입, 다른 값을 가져야한다면 생성자에서 필드를 초기화.
생성자 오버로딩 : 매개변술을 달리하는 생성자를 여러 개 선언하는 것
생성자 오버로딩이 많아짐 - 중복 코드 발생 - this를 사용하여 공통 코드를 가지고 있는 생성자를 호출함.


## 3주차 배운 내용
- 메소드 선언: 객체의 동작을 실행 블록으로 정의하는 것
- 메소드 호출: 실행 블록을 실제로 실행하는 것
- 메소드 선언 방법
 리턴 타입 메소드명 (매개변수)
 {
         실행블록
 }
메소드는 객체의 동작이므로 객체가 존재하지 않으면 메소드를 호출할 수 없다.
내부 객체의 경우 메소드명으로 호출, 외부 객체의 경우 참조변수,도트(.),연산자를 이용해 호출

-가변길이 매개변수는 매개변수의 위치에 (타입 ... values)가 들어온다.
ex) int sum(int ... values)

return문: 메소드의 실행을 강제 종료하고 호출한 곳으로 돌아감.

메소드 오버로딩: 메소드 이름은 같되 매개변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것
목적: 다양한 매개값을 처리하기 위함(매개값의 타입이 int,double 두가지라면 오버로딩 사용)
ex) println은 대표적인 메소드 오버로딩이다.

인스턴스 멤버: 객체에 소속된 멤버(객체를 생성해야만 사용할 수 있음) - 외부 클래스에서 사용하기 위해서는 객체를 생성한뒤 참조변수(.)를 사용하여 접근해야됨.
정적 멤버: 클래스에 고정된 멤버 (객체 없이 사용 가능)
this: 클래스 내부에서 현재 객체에 접근할때 사용함.(인스턴스 필드임을 강조할때 주로 사용)

정적 멤버: 메소드 영역의 클래스에 고정적으로 위치하는 멤버(객체 생성 필요없이 클래스를 통해 바로 사용가능)
           객체마다 가지고 있을 필요가 없는 공용적인 필드는 정적 필드로 선언.(Pi같은 것)
           클래스 이름으로 호출이 가능하다.
           
인스턴스 메소드와 정적 메소드의 차이점: 인스턴스 메소드는 매개변수로 객체를 가져야 하지만, 정적 메소드는 그렇지 않다.
인스턴스 필드는 객체에 속하며 상태를 나타내지만, 정적 필드는 클래스에 소유되며 모든 인스턴스가 고유하는 값을 나타낸다.

정적 멤버는 객체없이 실행되므로 인스턴스 멤버를 사용할 수 없다. --- 객체를 먼저 생성하고 참조 변수로 접근해야됨

final 필드: 초기값이 저장되면 이것이 최종값이 되어서 실행 도중에 수정할 수 없게 된다.
초기값을 줄 수 있는 방법
1.필드 선언 시에 초기값 대입
2.생성자에서 초기값 대입

패키지 선언: pubic class 클래스명{...}. 패키지명은 모두 소문자로 적는다.
회사 도메인 이름의 역순으로 작성, 마지막에는 프로젝트이름을 붙여준다.

 
import 문: 다른 패키지에 있는 클래스를 사용하기 위함. 패키지와 클래스 선언 사이.
import 패키지 이름.클래스 이름;
다수의 클래스를 사용할 떄에는 클래스 이름을 생략하고 * 을 사용한다.

## 4주차 배운 내용
- 접근 제한자: 중요 필드,메소드의 외부 노출을 막아 무결성을 유지하기 위한 기능(public, protected, private)
- 클래스의 접근 제한
         default: 다른 패키지에서 사용X
         public: 다른 패키지에서 사용 O
         
- 생성자의 접근 제한
         public: 모든 패키지
         defalut: 같은 패키지
         private: 클래스 내

-필드와 메소드의 접근 제한
         public: 모든 패키지
         default: 같은 패키지
         private: 클래스 내부
         
-
## 5주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 6주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 7주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 8주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 9주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 10주차 배운 내용
- 이곳에 작성하시면 됩니다.
