# Amicom 자바 스터디 연습장

- 아미콤 자바 스터디 전용 레포지토리입니다.
- 매 주차마다 학습 내용과 실습 내용을 README 파일과 main 클래스 파일에 자유롭게 작성합니다.
- 정해진 작성 형식은 없습니다.

## 1주차 배운 내용
- -참조 타입:객체의 번지를 참조하는 타입(배열,열거,클래스,인터페이스 타입등) -객체 : 데이터+메소드(메소드는 C의 함수같은 것)

-메소드 영역: 바이트코드 파일을 읽은 내용이 저장되는 영역 -힙 영역: 객체가 생성되는 영역 -스택 영역: 메소드를 호출할 때마다 생성된는 프레임이 저장되는 영역

==,!=연산자로 번지를 비교(같은 객체인지 구분) -null: 아직 번지를 저장하고 있지 않다 
-예외(exception): 프로그램 실행 도중 발생하는 오류
-null exception: 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 떄 발생 --- 참조 변수가 객체를 정확히 참조하도록 번지를 대입 
-어떤 변수에도 객체 참조X --- 해당 객체는 프로그램에서 사용X --- 쓰레기 수집기로 자동 제거됨
-String: 문자열 객체 -new 연산자: 새로운 객체를 만드는 객체 생성 연산자 
-equals()메소드: 내부 문자열만을 비교 
-charAt()메소드: 매개값으로 주어진 인덱스의 문자를 리턴 (ex charAt(3)은 해당 문자열의 3번쩨 문자를 의미) (인덱스: 0부터 문자열 길이-1까지의 번호 --- 0부터 세기 떄문) 
-length()메소드: 문자열에서 문자의 개수(공백 포함) 
-replace()메소드: 기존 문자열은 그대로 두고, 대체한 새로운 문자열을 리턴(수정하는 것이 아닌 새로운 문자열 생성) 
-substring()메소드: 특정 위치의 문자열을 잘라내어 가져옴(괄호안에 콤마를 넣어 범위를 지정할 수 있음 (시작인덱스,종료 인덱스 앞))//(0,9)이면 0번인덱부터 8번인덱스까지 
-indexOf()메소드: 특정 문자열의 위치를 찾음(주어진 문자열의 시작되는 인덱스를 리턴함) 
-contains()메소드: 주어진 문자열이 단순히 포함되어 있는지만 조사(true, false로 구분) 
-split()메소드: 구분자가 사용된 문자열을 분리함("번호,제목,내용,설명"--- "번호" "제목" "내용" "성명")

-배열: 연속된 공간에 값을 나열시키고, 각 값에 인덱스를 부여한 자료구조(많은 변수가 필요할 떄 유용) 
배열은 같은 타입의 값만 관리 배열의 길이는 늘리거나 줄일 수 없다. --- 새로운 배열을 생성한 뒤 기존 값을 복사하자. 
선언 방법 - 타입[] 변수; (길이는 0부터 시작한다.) 
새로운 변수 선언: 타입[] 변수이름= new 타입[길이] 대입연산자로 해당 인덱스의 내용을 바꿀 수 있다. 
배열변수.length; : 배열의 길이를 얻을 수 있다.(반복문 사용시 배열 안 항목을 일일이 세지 않아도 된다.) 
배열 복사: 
1.System.arraycopy(원본배열,시작 인덱스, 새 배열, 붙여넣기 시작, 복사 항목) 
2.for(타입 변수: 배열) { 실행문 }

다차원 배열: 타입 [][]... 변수이름 = { {(0,1),(0,2),(0,3)...} --- 0번째 배열 {(1,1),(1,2),(1,3)...} --- 1번째 배열 }

Java 시작문이 배열인 이유 = 시작값과 종료값등 실행에 필요한 값이 존재하기 떄문

-열거 타입: 한정된 값을 갖는 타입 첫 문자는 대문자로 캐멀 스타일 데이터 타입 일종이므로 변수 선언 뒤 사용 -열거 상수: 열거 타입으로 사용할 수 있는 한정된 값 알파벳으로 정의 모두 대문자 단어 사이에는 언더바로 연결

## 2주차 배운 내용
- 객체 : 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것
- 필드 : 속성
- 메소드 : 동작, 객체들 사이의 상호작용 수
- 객체 모델링 : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
- 매개값 : 메소드가 실행할 때 필요한 값.
- 리턴값 : 메소드 실행의 결과. 호출한 곳으로 돌려준다.

- 객체 간의 간계
집합관계 : 완성품과 부품의 관계(자동차와 엔진,타이어,핸들의 관계)
사용관계 : 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계(사람이 자동차에게 달린다라는 메소드 호출)
상속관계 : 부모와 자식 관계(자동차가 기계의 필드,메소드를 물려받음)

-객체 지향 프로그래밍의 특징
캡슐화 : 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것(외부 객체는 노출되는 필드,메소드만 이용가능)
         외부의 잘못된 사용으로 객체가 손상되는 것을 막음. 접근 제한자로 캡슐화된 멤버의 노출을 선택할 수 있음
         
상속 : 부모 객체의 필드와 메소드를 자식 객체에게 물려주는 것
       코드의 재사용성을 높여줌(자식 객체에서 중복 코딩 막아줌)
       유지 보수 시간을 최소화 시켜줌(부모 객체의 필드, 메소드를 수정하면 자식 객체에서도 수정된 것을 사용)

다형성 : 동일한 사용 방법에서 실행 결과가 다양하게 나오는 성질(부품에 해당하는 객체를 바꾸면 프로그램 성능이 다르게 나올 수 있음)

-객체와 클래스
클래스 : 설계도에 해당
클래스의 인스턴스 : 클래스로부터 생성된 객체(동일한 클래스로부터 여러 개의 인스턴스(객체)를 만들 수 있음)

-클래스 선언
public class : 공개 클래스를 선언함 (클래스명은 첫 문자는 대문자로, 캐멀 스타일 작성. 첫 문자 숫자X, $,_ 사용가능)
하나의 소스파일에 복수의 클래스를 선언 가능하나, 공개 클래슨느 소스파일명과 동일한 클래스만 가능

-객체 생성과 클래스 변수
new : 객체 생성 연산자 //새로 생성한 객체는 이전 객체와 다른 객체로 인식한다.
클래스 변수 = new 클래스();
클래스의 용도
        1. 라이브러리 클래스 : 실행할 수 없으며 다른 클래스에서 이용하는 클래스
        2. 실행 클래스 : 메소드를 가지고 있는 실행 가능한 클래스

- 클래스의 구성 멤버
필드 : 객체의 데이터가 저장되는 곳 ( 변수선언과 비슷하지만 쓰임새 다름)
생성자 : 객체 생성시 초기화 역할 담당 ( 메소드 선언과 비슷하지만, 리턴이 없고 클래스 이름과 동일함)
메소드 : 객체가 수행할 동작(다른 프로그래밍 언어의 함수와 비슷)

- 필드 선언과 사용
필드 : 객체의 데이터를 저장하는 역할 ( 고유 데이터, 현재 상태 데이터, 부품 데이터)
필드 선언 : 타입 필드명 [ = 초기값]; (변수 선언과 동일하나 클래스 블록에서 선언하여야 한다)
필드 사용 : 필드값을 읽고 변경하는 것 ( 클래스로부터 객체가 생성되야 사용 가능)
도트(.) : 객체 접근 연산자. 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙인다.

-생성자 선언과 호출
클래스에 생성자 선언이 없으면 기본 생성자가 자동 추가된다.
동일한 객체 값일때 필드선언시 초기값 대입, 다른 값을 가져야한다면 생성자에서 필드를 초기화.
생성자 오버로딩 : 매개변술을 달리하는 생성자를 여러 개 선언하는 것
생성자 오버로딩이 많아짐 - 중복 코드 발생 - this를 사용하여 공통 코드를 가지고 있는 생성자를 호출함.




## 3주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 4주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 5주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 6주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 7주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 8주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 9주차 배운 내용
- 이곳에 작성하시면 됩니다.

## 10주차 배운 내용
- 이곳에 작성하시면 됩니다.
